
===========================================================================

			glclock Mark について

	２０００年６月
	Masa（川瀬 正樹）
	E-Mail: masa@daionet.gr.jp
	URL   : http://www.daionet.gr.jp/~masa

===========================================================================

■■ 目次 ■■

・glclock Mark とは？
・測定方法
・測定結果
・オプション
・ベンチマーク結果大募集中
・ベンチマーク内容の詳細について
・1. Per-Vertex Lighting Mark.
・2. Per-Vertex Lighted Texturing Mark.
・3. Texture Filtering Mark.
・4. Environment Mapping Mark.
・5. Super Sampled Blending Mark.
・6. Maximum Triangles Mark.
・7. OpenGL Practical Rendering Mark.
・注意事項一覧

----------------------------------------------------------------------------

■■ glclock Mark とは？ ■■

glclock Mark は、glclock 専用の OpenGL ベンチマークソフトです。
glclock-5.0 以前のスクリプト（バッチファイル）による簡易ベンチマークとは内容が
まったく異なっています。
OpenGL の描画速度をある程度詳細に測定することができます。

OpenGL のさまざまな機能（ライティング、テクスチャマッピング、環境マッピング、
ブレンディング、ポリゴンスループット etc.）の処理速度を測定し、結果をテキスト
ログ出力および、HTML フォーマットでグラフ化します。
OpenGL の速度や特性（得手／不得手等）が一目で良く判ります。


■■ 測定方法 ■■

常駐ソフトなどをなるべく終了させ、スクリーンセーバ等も OFF にしてから、
glclockmark* を実行します。
テストによっては大量のメモリを使用しますので、できるだけ他のソフトは終了させて
おいてください。

ある程度本格的なテストを行うため、測定にはそれなりに時間がかかります。
タイマー精度が悪いほど、また OpenGLの処理速度が遅いほど、測定時間は長くなります。
タイマー精度が良く、OpenGL をアクセラレートできる環境なら、およそ７分〜１５分
程度で終了します。

タイマー精度が低い場合やソフトウェア実行の環境ではかなり時間がかかります。
３０分〜１時間以上かかる場合もあります。

※テストの間に、まれに１０秒〜２０秒ほど処理が止まる（固まる）ことがありますが、
　ほぼ間違いなく復帰しますので、止まったように見えても２０秒くらいは様子を見て
　ください。


■■ 測定結果 ■■

結果は、glclockmark.log および、glclockmark.html というファイルに出力されます。
Windows 版ではブラウザが自動的に起動します。

glclock Mark のスコアは、PentiumII-233MHz + RivaTNT PCI-16MB 320 x 320 x 16bpp
の環境に対する速度比（パーセンテージ表記）になります。
その他、FPS (Frames Per-Second ), kTPS (kilo-Triangles Per-Second) の最大値や、
さまざまな性能の詳細を出力します。

結果の glclockmark*.log ファイルを glclockmark の第一引数に指定して実行すると、
テストをいっさい実行せずに、*.log ファイルからすぐに HTML を生成します。
この場合は、*.log ファイルと同名の *.html ファイルに出力されます。
※つまり、*.log ファイルだけがあれば、HTML ファイルはいつでも生成できます。
Windows 版では、*.log ファイルを glclockmark にドラッグ＆ドロップするだけで
OK です。

アーカイブには「glclockmark_ref_Win98-PII233-TNT-PCI16MB.log」というファイルが
含まれていますが、これはスコアの計算に必要な参照ログファイルですので、削除したり
変更したりしないでください。


■■ オプション ■■

glclockmark にはいくつかの起動オプションがあります。
Windows 版では、ショートカットに任意のオプションを追加してください。

　● ウィンドウサイズ変更

　　-VGA, -SVGA, -XGA
　　といったオプションで、デフォルトとは違ったウィンドウサイズで測定できます。
　　この場合は glclockmark_VGA.log, glclockmark_VGA.html などといったファイル
　　名で結果出力されます。

　　また、glclockmark_ALL というスクリプトを実行すると、すべてのウィンドウサイズ
　　のテストを連続して行います。
　　glclockmark_ALL の実行には相当時間がかかりますので（ハードウェア描画でも
　　２０分〜３０分以上）、お出かけの前など、しばらく使わない時に実行した方が
　　良いでしょう。

　● 測定回数指定

　　-loop n
　　オプションで、ｎで指定された回数測定を繰り返し、測定精度を向上させます。

　　glclock Mark の測定中は、スワップその他の原因により、一部のテストのスコアが
　　本来の性能より落ちこむことがあります。
　　複数回の測定結果から最適化することで、このような現象を軽減します。
　　デフォルトは１回で、ｎには１〜８までを指定できます。

　　回数が多くなるほど、スコアは本来の性能に近づきますが、測定時間は回数に比例
　　して長くなります。
　　ソフトウェア環境では時間がかかり過ぎるためお勧めできませんが、ハードウェア
　　アクセラレーションが可能な環境で、より良いスコアをマークしたい場合は、
　　glclockmark -loop 4
　　程度で測定されることをお勧めします。

　　なお、glclockmark_ALL スクリプトにオプションを与えると、すべてのサイズに
　　対して同じオプションが追加されます。
　　例えば
　　glclockmark_ALL -loop 4
　　と実行すると、すべてのウィンドウサイズのテストをそれぞれ４回ずつ測定します。

　● 追加モード

　　-ADD
　　以前測定したログファイル（glclockmark.log, glclockmark_VGA.log etc.）が
　　残っている場合のみ、追加モードとなります。

　　測定は以前の実行結果への追加とみなされます。
　　以前のログと新たに測定したログの両方で最適化されるため、-loop オプションと
　　同じく、スコアがより本来の性能に近づきます。

　　何度か測定する場合は、このオプションを指定しておくことをお勧めします。
　　測定する毎にログが最適化され、本来の性能に近づきます。

　　ただし、以前の測定時から測定環境が変化している場合（グラフィックスカードを
　　入れ替えた場合等）は、正しい結果になりませんので、このオプションは指定
　　しないでください。

　● テスト項目の指定

　　+1 〜 +7 および -1 〜 -7 というオプションで、７項目（後述）のうちから
　　実際にテストする項目を指定できます。

　　+ で指定した項目番号のテストが有効になり、
　　- で指定した項目番号のテストが無効になります。
　　何も指定しなければ、すべての項目のテストを行います。
　　+ オプションが１つでも指定されると、+ を付けた番号を除くすべてのテストが
　　無効になります。

　　指定例：
　　　glclockmark		… すべての項目をテストします。
　　　glclockmark -1 -3		… 1, 3 を除くすべての項目をテストします。
　　　glclockmark +1 +2		… 1, 2 項目のみをテストします。

　　※テストを行わなかったスコアは無効ですので、全体のスコアもより低くなります。

　● シングルバッファ／ダブルバッファ

　　-SINGLE	… シングルバッファリングモードのみをテストします。
　　-DOUBLE	… ダブルバッファリングモードのみをテストします。

　　両方指定された場合は無効です（デフォルトと同じく、シングルバッファ／ダブル
　　バッファの両方をテストします）。


以上の glclock Mark のオプションとして認識できなかった引数は、glclock にそのまま
渡されます。
例えば、
glclockmark -TC
とすると、可能であれば圧縮テクスチャフォーマットを使用してテストを行います。


■■ ベンチマーク結果大募集中 ■■

glclock-5.0 以前とは内容がまったく異なっておりますので、新たに結果を大募集して
います。
どのような環境でも結構ですので、結果報告を頂けると大変参考になります。
頂いた結果は、随時 glclock Mark Data Base のページ
<http://www.daionet.gr.jp/~masa/glclock/glclockmark/index.html>
に追加アップしていきたいと思います。

現在特に募集中の環境は、
・3Dlabs 系のハイエンドグラフィクスカード
・Intens3D Wildcat シリーズ
・Matrox G400
などです。

結果を報告してくださる場合は、できるだけ下記の事項を守ってください。

　● glclockmark.html ではファイルサイズがかなり大きくなってしまうため、同時に
　　作成される *.log ファイルをメール < masa@daionet.gr.jp > に添付してください。

　● デフォルトウィンドウサイズだけではなく、-VGA, -SVGA, -XGA オプションを
　　つけた結果もお願いします。
　　すべてをテストするのにはかなり時間がかかるので恐縮ではありますが…。
　　各々の結果は、glclockmark_VGA.log, glclockmark_SVGA.log といったファイル名で
　　出力されます。

　● 画面モードは、可能であれば 16 ビット（High Color）モードでお願いします。
　　もちろん、24 ビット、32 ビットモードの結果も合わせて頂ければ、それに越した
　　ことはありません。
　　あくまで測定する際の優先度の問題です。

　● もし時間に余裕があれば、-loop で、数回の測定を行って頂けると助かります。
　　例えば -loop 4 と指定して測定すると、４回の測定結果を最適化するため、
　　より本来の性能に近いスコアを得ることができます。
　　ただし、この場合は４回分の測定時間が必要になってしまいます。

　● CPU、CPU クロック、OS といったマシンの情報と、ビデオチップ（チップ名）、
　　ビデオカード（製品名）、バスタイプ（PCI/AGP）、搭載メモリ（VRAM 容量）と
　　いったグラフィックスカードの情報、また測定の際のディスプレイ解像度、色数情報
　　などを、判る範囲で結構ですのでお知らせください。
　　また、CPU やグラフィックスカードをオーバクロックしている方は、
　　その情報（定格クロック、テスト時のクロック）もお知らせください。


■■ ベンチマーク内容の詳細について ■■

以下は、glclock Mark のテスト内容の詳細です。
興味のある方はお読みください。

glclock Mark は、OpenGL の速度を、７種類の大きな項目に分類して測定します。
この分類はほとんど作者の趣味（というか個人的に知りたい能力）になっていますが、
一般的にもある程度は参考になるはずです。

　● 1. Per-Vertex Lighting Mark.
　　OpenGL API の頂点単位のライティング（光源処理：シェーディング）能力

　● 2. Per-Vertex Lighted Texturing Mark.
　　テクスチャとライティングを同時に行った際の描画能力

　● 3. Texture Filtering Mark.
　　さまざまなテクスチャ・フィルタリングの描画能力

　● 4. Environment Mapping Mark.
　　環境マッピング使用時の描画能力

　● 5. Super Sampled Blending Mark.
　　スーパサンプリング描画（主にαブレンディング）能力

　● 6. Maximum Triangles Mark.
　　ポリゴンスループット（ほぼ純粋なポリゴン描画能力）

　● 7. OpenGL Practical Rendering Mark.
　　さまざまな機能を応用した実用的な描画能力

これらのスコアはすべて参照環境に対するパーセンテージとなっており、さらに、
glclock Mark の最終的な総合スコアは、上の各々の項目のスコア（参照環境に対する
パーセンテージ）の総平均値となります。

glclock Mark =
	( Per-Vertex Lighting Mark +
	  Per-Vertex Lighted Texturing Mark +
	  Texture Filtering Mark +
	  Environment Mapping Mark +
	  Maximum Triangles Mark +
	  OpenGL Practical Rendering Mark ) / 7

総合スコアは、テスト環境のさまざまな能力の特性を抑えつけた結果とも言えます。
総合スコアだけで OpenGL の能力を判断することは危険ですので止めましょう。

それぞれの項目のスコアにより、テスト環境の OpenGL の特性を知ることができます。

たとえば、CAD などの分野では、
1. Per-Vertex Lighting Mark.
6. Maximum Triangles Mark.
のスコアが特に重要な意味をもちます。

ゲームなどでは、
3. Texture Filtering Mark.
が特に重要です。

将来的には、
5. Super Sampled Blending Mark.
7. OpenGL Practical Rendering Mark.
なども重要です。

他に、ラディオシティで予め計算しておいた明るさに従って描画するような用途
（室内の証明シミュレーションなど）の場合は、
6. Maximum Triangles Mark.
のスコアが特に重要です。


以下では、各項目の詳細を説明します。

各項目のスコアは、まずその項目に属しているテストの FPS を元に、テスト毎の重要性、
負荷に従った重みを付けた平均（重みを付けるため正確には平均ではない）FPS 値を
計算します。
そして、同じ方法で計算した参照環境の FPS 値に対する速度比（パーセンテージ）と
なります。

各々のテストでは、同じ内容でダブルバッファリング、シングルバッファリングの
２種類の速度を測定し、そのうちの速い方（FPS の高い方）を採用します。


■■ 1. Per-Vertex Lighting Mark. ■■

OpenGL API の頂点単位のライティング（光源処理：シェーディング）能力です。
光源計算の種類による６種類の能力（平行光源、点光源、スポットライト etc.）の
違いに分類して測定します。
さらに、それぞれの光源毎に、処理する光源数１、２、４、８個の速度を測定します。
光源計算の複雑さや個数による処理速度の変化を詳細に知ることができます。

　● Directional Light(s).

　　平行光源です。
　　視線ベクトル、光線ベクトルは固定で、減衰もしないもっとも単純な計算です。
　　さらに、光源数１，２、４，８個による違いを測定します。

　● Directional Light(s) with Local Viewer.

　　平行光源ですが、視線ベクトルを頂点毎に正確に計算します。
　　光源数１，２、４，８個による違いを測定します。

　● Point Light(s).

　　点光源です。
　　頂点毎に光線ベクトルの再計算が必要で、さらに光源から頂点までの距離の二乗に
　　反比例して光の強さを減衰させます。
　　光源数１，２、４，８個による違いを測定します。

　● Point Light(s) with Local Viewer.

　　点光源に加え、視線ベクトルを頂点毎に正確に計算します。
　　光源数１，２、４，８個による違いを測定します。

　● Spot Light(s).

　　スポットライトです。
　　点光源と同じく頂点毎に光線ベクトルの再計算が必要で、光源から頂点までの距離の
　　二乗に反比例して光が減衰します。
　　加えて、特定の方向に強い光を放ち、その方向から離れるにしたがい急激に減衰
　　させます。
　　光源数１，２、４，８個による違いを測定します。

　● Spot Light(s) with Local Viewer.

　　スポットライトに加え、視線ベクトルを頂点毎に正確に計算します。
　　もっとも複雑な光源計算モデルです。
　　光源数１，２、４，８個による違いを測定します。


■■ 2. Per-Vertex Lighted Texturing Mark. ■■

テクスチャとライティング処理を同時に行う能力です。
さらに、テクスチャとライティング後カラーのブレンド方法による違い（２種類）に
分類します。
スペキュラーの表現方法の違いによる速度差を知ることができます。
さらにそれぞれの項目毎に、６種類の光源（1. Per-Vertex Lighting Mark. と同様の
６種類）に分けて測定します。

　● Single Color Blending.

　　スペキュラーも含むすべてのライティングの結果とテクスチャのカラーとを、
　　単純に乗算（変調：モデュレート）します。
　　OpenGL 標準の計算方法ですが、スペキュラーの色までテクスチャの影響を受けて
　　しまうため、綺麗なスペキュラーを表現できません。

　　さらに、６種類の光源に分けて測定します。

　● Separate Specular Color Blending.

　　スペキュラーとそれ以外のライティング結果を個別に保持しておき、
　　まずテクスチャとのブレンディングはスペキュラー以外のライティング結果で
　　乗算します。
　　そして、テクスチャとのブレンディングの後にスペキュラーを別途加算します。
　　これにより、光源の色に輝く美しいスペキュラーを表現できます。

　　OpenGL の実行環境が OpenGL-1.2 以降もしくは、
　　GL_ARB_separate_specular_color, GL_EXT_separate_specular_color のいずれかを
　　サポートしている場合、１パスレンダリングで実行できます。

　　サポートしていない環境の場合、まずスペキュラー以外でライティングした結果と
　　テクスチャをブレンドして描画し、その後にスペキュラーだけを計算して
　　加算ブレンディングするという、２段階の描画（２パスレンダリング）が必要に
　　なります。
　　このため、速度は半分近くまで低下します。

　　この項目内で、さらに６種類の光源に分けて測定します。


■■ 3. Texture Filtering Mark. ■■

テクスチャマッピングの処理能力です。
５種類のテクスチャ・フィルタリングに分類します。
フィルタの種類による速度の違いを知ることができます。

　● Nearest Point Sampling.

　　ポイントサンプリング。
　　フィルタリングを行いません。
　　目的のテクスチャ座標の存在するテクセル１点の色をそのままテクスチャカラー
　　として使用します。

　● Mip-Mapping.

　　ミップマッピング。
　　テクスチャを縮小した際のモアレなどのエイリアシングを除去するフィルタ。
　　予めフィルタをかけて縮小した大きさの異なる複数のミップマップテクスチャを
　　用意しておき、テクスチャマッピング時に、テクスチャの縮小率にもっとも適した
　　テクスチャを選択します。
　　選択されたレベルのテクスチャから、目的のテクスチャ座標の存在するテクセル
　　１点の色をテクスチャカラーとして使用します。

　● Bi-Linear Filtering.

　　バイリニア・フィルタリング。
　　目的のテクスチャ座標の近傍４テクセルから、距離に応じて線形補間した色を
　　テクスチャカラーとして使用します。

　● Bi-Linear Filtering with Mip-Mapping.

　　ミップマップを使ったバイリニア・フィルタリング。
　　テクスチャの縮小率にもっとも適したレベルのミップマップテクスチャを使って
　　バイリニア・フィルタリングを行います。

　● Tri-Linear Filtering (Bi-Linear with Mip-Map Linear).

　　２レベル間のバイリニア・フィルタリングの結果をさらに補間。
　　近傍２レベルのミップマップテクスチャでそれぞれバイリニア・フィルタリングを
　　施し、その結果を２レベルのミップマップからの距離に従ってさらに線形補間します。
　　テクスチャカラーは８テクセルから補間された色になります。


■■ 4. Environment Mapping Mark. ■■

動的にテクスチャ座標を生成する「テクスチャ座標自動生成」系の処理の中でも
計算負荷の高い環境マッピングの処理能力です。
環境マッピングにもさまざまな種類がありますが、ここで対象としているのは
スフィア・マッピングです。
主に金属などの周囲の背景の反射を表現するために使われますが、予め計算して作成
したスペキュラーの環境マップを使用すれば、テクセル単位のスペキュラー表現が可能に
なります。
これは擬似的なフォン・シェーディング（Phong Shading）とも言える手法であり、
グロー・シェーディング（Gouraud Shading）では表現しきれない鋭いスペキュラーを
高速に（あくまで擬似的にですが）表現できます。

単純なスフィア・マッピングによる描画と、αブレンド（加算モード）および両面
レンダリングによる描画の２種類の速度を測定します。

　● Sphere Mapping.

　　単純なスフィア・マッピングによる描画です。
　　主に金属表現に利用します。

　● Double Sided Transparency Sphere Mapping without Z-Buffer.

　　スフィア・マッピングを、両面レンダリング、Ｚバッファなしの条件で
　　どんどんブレンディング（加算混合）します。
　　ガラスのように、透明でスペキュラーのみが強く現れる素材の表現に適した描画です。


■■ 5. Super Sampled Blending Mark. ■■

複数枚のレンダリング結果を平均化して最終画像を生成するスーパサンプリングを使い、
主にブレンディングの処理能力を測定します。

通常このようなスーパサンプリングでは、OpenGL のアキュムレーションバッファ
（積算バッファ）を利用することで、非常に高画質の画像を生成することができます。
しかし、ほとんどの環境ではアキュムレーションバッファへの積算がソフトウェア
処理のブレンディングになるため、速度が極端に低下します。
ここでは、ハードウェアを利用してブレンドを行い、より高速に平均画像を生成する方法
を使います（ただし OpenGL をハードウェアサポートしない環境では、いずれにしても
ソフトウェア処理になります）。

サンプリング数、ブレンディングの方法により３種類のテストを行います。

　● 4 Sampling Additive-Blended Object Motion-Blur without Z-Buffer (total 4-pass).

　　１／４の明るさの描画を４回加算描画することで、４サンプリングを平均した
　　モーションブラーを行います。
　　加算はオブジェクト（時計）に対してのみ行うため（つまり全画面書き換えを行わ
　　ないため）それなりに高速に処理できますが、画質は悪くなります。

　● 4 Sampling Alpha-Blended Scene Anti-Aliasing with Z-Buffer Mask (total 7-pass).

　　４サンプリングのシーン・アンティエイリアシングです。
　　サンプリング毎に、全画面のＺバッファ（深度情報）のみを先に作成します。
　　その後、ｎ回目のサンプリングでは１／ｎのα値を使って以前の結果に全画面描画を
　　ブレンドします。

　　２回目以降の描画では、先に作成したＺバッファをマスクとして使い、全ピクセル
　　に対し１回のみ描画されることを保証します。
　　ｎ回目の描画を１／ｎの半透明で全画面ブレンドすることにより、任意の回数の
　　サンプリング結果を、より美しく平均化することができます。
　　単純な加算合成よりも画質は向上しますが、４サンプリングの画像生成に、
　　Ｚバッファと合わせて合計７パスの全画面レンダリングが必要になるため、速度は
　　低下します。

　● 7 Sampling Alpha-Blended Depth of Field Blur with Z-Buffer Mask (total 13-pass).

　　７サンプリングの被写界深度ブラー（ピンぼけ）です。
　　ブレンディングの方法は上の描画と同じですが、７サンプリングの画像を生成する
　　ため、Ｚバッファを含め合計で１３パスの全画面レンダリングを行います。
　　その分さらに速度は低下しますが、アキュムレーションバッファによるソフトウェア
　　ブレンディングと比較すれば、遥かに高速に処理できます。


■■ 6. Maximum Triangles Mark. ■■

１４万ポリゴン以上から成る巨大なモデルを描画し、テスト環境のポリゴンスループット
を測定します。
実際には両面／片面レンダリング、独立ポリゴン、Strip/Fan、αブレンディング、
クリッピング、大／小ポリゴンなどが入り混じった描画速度になるため、完全に純粋な
限界能力を測定できる訳ではありません。
環境によってはチップの限界値を超えることもあります（クリッピングの速い環境など）。

テクスチャなし、テクスチャありの描画で、さらにそれぞれを異なるフォグ方程式による
フォグ処理を行います。
フォグ方程式の違いは以下の通りです。

・Non-Fogging.（フォグなし）		f = 1
・Linear Equation Fogging.		f = (end - z) / (end - start)
・1 Exponential Equation Fogging.	f = e ^ (density * z)
・2 Exponential Equation Fogging.	f = e ^ ((density * z) ^ 2)

　● Simple Coloring.

　　頂点カラー指定の単純なポリゴン描画です。
　　さらに４種類のフォグモードに分類します。

　● Modulate Texture Mapping.

　　テクスチャマッピング（頂点カラーとの乗算ブレンディング）の描画能力です。
　　４種類のフォグモードに分類します。


■■ 7. OpenGL Practical Rendering Mark. ■■

ライティング、マルチテクスチャ（ソリッドテクスチャマッピング、環境マッピング）、
αブレンディング、フォグといったさまざまな機能を組み合わせた実用的な描画能力を
測定します。

OpenGL のコンパイルおよび実行環境の双方（Windows では実行環境のみで可）が、
GL_ARB_multitexture, GL_EXT_multitexture, GL_SGIS_multitexture のいずれかを
サポートしている場合、１パスでマルチテクスチャ処理を行えるため、より高速に実行
できます。
もっともすべての描画にマルチテクスチャを使っている訳ではありませんので、
あまり極端な差はでません。

描画の複雑さによって２段階に分類します。

　　● 5 Directional Lights, Multi-Texture (Solid Texture, Specular Map), Blending, Linear Fog.

　　平行光源（５個）、マルチテクスチャ、αブレンディング、線形フォグを使用した
　　描画を行います。

　　● 5 Point Lights with local Viewer, Multi-Texture (Solid Texture, Specular Map), Blending, Reflection, 1 Exponential Fog, High Detail.

　　点光源（５個）、視線ベクトル計算、マルチテクスチャ、αブレンディング、
　　一部のオブジェクトの映り込み処理、指数フォグを使用した描画を行います。
　　また、ポリゴン数の多い複雑なモデルを使います。

3Dfx Voodoo シリーズや Matrox G400 では、マルチテクスチャの処理に一部バグがあるらしく、マルチテクスチャ拡張機能を有効にすると、正常な描画を行えなくなります。
その状態で測定するとスコアが不自然に高くなるため、これらの環境では
マルチテクスチャ拡張機能を無効にしています。
したがって、これらの環境では本来の性能より多少低いスコアになります。

glclock Mark のスコアで、おそらく最大１０％程度低くなります。


■■ 注意事項一覧 ■■

注意事項を簡単にまとめます。

　● メモリや CPU リソースを大量に使いますので、他のアプリケーションは
　　できるだけ終了させてください。
　　また、スクリーンセーバはかならず切っておいてください。

　● 実行にはそれなりに時間がかかります。
　　OpenGL をハードウェア実行できる環境で早くて７〜１０分、ソフトウェア描画では、
　　３０分〜１時間以上かかることがあります。

　● 実行中、まれに１０秒〜２０秒ほど動作が止まる（固まる）ことがありますが、
　　ほとんどの場合は復帰しますので、２０秒くらいは様子をみてください。

　● glclock Mark の値は、あくまでもこのソフトウェアによる実測値の平均値です。
　　計算の仕方によっても変化するような値ですから、この値だけで OpenGL の性能を
　　評価しないでください。
　　少なくとも７項目の各スコアを考慮に入れるようにしてください。


===========================================================================
http://www.daionet.gr.jp/~masa/
masa@daionet.gr.jp
===========================================================================
